#!/bin/sh

set -e

AR=${AR:-ar}

# Make "append FOO item1 item2 ..." available for list like variable FOO
decl_list()
{
  eval "${1}_append() {
    $1=\"\$$1\${$1:+ }\$*\";
  }"
}

def_list()
{
  eval "$1=''"
  decl_list "$1"
}

append()
{
  append_arg_=$1
  shift
  "${append_arg_}_append" "$@"
}

decl_list MODULES

# Initialize with build configuration
if [ -f "${BUILD_CONFIG:=./build.conf}" ]; then . "$BUILD_CONFIG"; fi

if [ -z "$MODULES" ]; then
  echo "Build modules not defined in environment or $BUILD_CONFIG" >&2
  exit 1
fi
readonly MODULES

case "${BUILD_SOURCE_DIR:=src}" in
(/*) ;; (*) BUILD_SOURCE_DIR="$(dirname "$BUILD_CONFIG")/$BUILD_SOURCE_DIR";;
esac

case "${BUILD_INCLUDE_DIR:=include}" in
(/*) ;; (*) BUILD_INCLUDE_DIR="$(dirname "$BUILD_CONFIG")/$BUILD_INCLUDE_DIR";;
esac

TARGET_NAME="${TARGET_NAME:-target}"
readonly TARGET_TEMP_DIR="${TARGET_TEMP_DIR:-$TARGET_NAME/tmp}"
readonly BUILD_SOURCE_DIR BUILD_INCLUDE_DIR TARGET_NAME

# General directories
readonly TARGET_LIBRARY_DIR="$TARGET_NAME/lib"
readonly TARGET_DEPEND_DIR="$TARGET_NAME/dep"
readonly TARGET_BINARY_DIR="$TARGET_NAME/bin"
readonly TARGET_OBJECT_DIR="$TARGET_NAME/obj"

# Module specific test binaries
readonly TARGET_TEST_BINARY_DIR="$TARGET_NAME/test"

# Generated sources
readonly TARGET_SOURCE_DIR="$TARGET_NAME/src"
readonly TARGET_INCLUDE_DIR="$TARGET_NAME/include"

# Module specific lists, defined when module configuration is sourced
def_list SOURCES
def_list OBJECTS
def_list HEADERS
def_list REQUIRE
def_list LINKER
def_list TESTS

BINARY=

require() { append REQUIRE "$@"; }
binary() { BINARY="${1:-$MODULE}"; }

define_object()
{
  MEMBER="${1%.o}"
  MEMBER_SOURCE="$MODULE_DIR/$2"
  shift 2

  append OBJECTS $MEMBER.o

  build_cc_target "$MODULE_OBJECT_DIR/$MEMBER.o" "$MEMBER_SOURCE"
  build_object_recipe "$MODULE_OBJECT_DIR/$MEMBER.o" "$MEMBER_SOURCE" "$@"
}

# Invoke the compiler with paths and module linkage included
build_source_target()
{
  TARGET_=$1
  shift
  printf '%s: %s\n' "$GENERATED_SOURCE_DIR/$TARGET_" "$*"
}

build_include_target()
{
  TARGET_=$1
  shift
  printf '%s: %s\n' "$TARGET_INCLUDE_DIR/$TARGET_" "$*"
}

build_cc_target()
{
  TARGET_=$1
  shift
  printf '%s: %s $(MODULE_HEADERS.%s)\n' "$TARGET_" "$*" "$MODULE"
}

build_ld_target()
{
  TARGET_=$1
  shift
  printf '%s: %s $(MODULE_LINK.%s)\n' "$TARGET_" "$*" "$MODULE"
}

build_bin_target()
{
  TARGET_=$1
  shift
  printf '%s: %s $(MODULE_LINK.%s) $(MODULE_HEADERS.%s)\n' \
    "$TARGET_" "$*" "$MODULE" "$MODULE"
}

build_end_target()
{
  echo
}

# Makefile rule generation
build_sh_recipe()
{
  printf '\t%s\n' "$*"
}

build_rm_recipe()
{
  printf '\trm -f -- %s\n' "$*"
}

build_cc_recipe()
{
  printf '\t$(CC) $(CFLAGS) $(CPPFLAGS) -I"%s" -I"%s" %s\n' \
    "$TARGET_INCLUDE_DIR" "$BUILD_INCLUDE_DIR" "$*"
}

build_ld_recipe()
{
  printf "\t\
\$(CC) \$(CFLAGS) \$(LDFLAGS) \
-L$TARGET_LIBRARY_DIR %s \
\$(MODULE_LDFLAGS.$MODULE)\n" \
    "$*"
}

# <object> <source> [<extra cc args>...]
# Output command to compile <source> into <object> with optional extra flags.
# Create path/to/foo.d from path/to/foo.o as a secondary output.
build_object_recipe()
{
  OBJECT_="$1"
  MKFILE_="${OBJECT_%.o}.d"
  SOURCE_="$2"
  shift 2

  build_cc_recipe "$@" \
    -MMD -MP -MT '$@' -MF "\"$MKFILE_"\" \
    -c "\"$SOURCE_"\" \
    -o "\"$OBJECT_"\"
}

# <archive> <member>
build_ar_recipe()
{
  printf '\t$(AR) -rc %s\n' "$*"
}

build_module_targets() {
  printf '%s: %s\n\n' "$MODULE" "$LIBRARY"
  printf '%s: %s\n\n' "lib$MODULE.a" "$LIBRARY"
  printf '.PHONY: %s %s\n\n' "$MODULE" "lib$MODULE.a"
  printf 'all: %s\n\n' "$MODULE"

  printf '%s:' "$LIBRARY"
  printf ' \\\n\t '"${MODULE_OBJECT_DIR}"'/%s' $OBJECTS
  printf '\n'
  build_ar_recipe -s '$@' '$?'
  build_ar_recipe "$DEPEND" '$(?:.o=.d)'
  build_rm_recipe '$(?:.o=.d)'
  build_end_target

  if [ "$BINARY" ]; then
    printf '%s: %s\n\n' "$MODULE" "$TARGET_BINARY_DIR/$BINARY"

    if [ "$BINARY" != "$MODULE" ]; then
      printf '%s: %s\n' "$BINARY" \
        "$TARGET_BINARY_DIR/$BINARY"
      printf '.PHONY: %s\n' "$BINARY"
    fi

    build_ld_target "$TARGET_BINARY_DIR/$BINARY" "$LIBRARY"
    build_ld_recipe "$LIBRARY" -o "\"$TARGET_BINARY_DIR/$BINARY\""
    build_end_target
  fi
}

build_mkdir() { if [ ! -d "$1" ]; then mkdir "$1"; fi; }

build_directories() {
  build_mkdir "$TARGET_NAME"
  build_mkdir "$TARGET_TEMP_DIR"
  build_mkdir "$TARGET_LIBRARY_DIR"
  build_mkdir "$TARGET_DEPEND_DIR"
  build_mkdir "$TARGET_BINARY_DIR"
  build_mkdir "$TARGET_OBJECT_DIR"

  build_mkdir "$TARGET_TEST_BINARY_DIR"
  build_mkdir "$TARGET_SOURCE_DIR"
  build_mkdir "$TARGET_INCLUDE_DIR"

  for MODULE in $MODULES; do
    # For object and dependency files
    build_mkdir "$TARGET_TEMP_DIR/$MODULE"
    build_mkdir "$TARGET_OBJECT_DIR/$MODULE"

    # For test object and dependency files
    build_mkdir "$TARGET_TEMP_DIR/$MODULE/test"

    # Test binaries
    build_mkdir "$TARGET_TEST_BINARY_DIR/$MODULE"

    # Generated files
    build_mkdir "$TARGET_SOURCE_DIR/$MODULE"
    build_mkdir "$TARGET_INCLUDE_DIR/$MODULE"
  done
}

build_prelude() {
  # Prelude rules
  printf 'all:\nclean: clean-dep clean-lib clean-bin\n'
  printf 'clean-dep: ; rm -f -- %s/*\n' "${TARGET_DEPEND_DIR:?}"
  printf 'clean-lib: ; rm -f -- %s/*\n' "${TARGET_LIBRARY_DIR:?}"
  printf 'clean-bin: ; rm -f -- %s/*\n\n' "${TARGET_BINARY_DIR:?}"
  printf '.PHONY: all clean clean-dep clean-lib clean-bin\n\n'
}

build_postlude() {
  printf 'list-tests:\n\tfor T in'
  for M in $MODULES; do printf ' $(MODULE_TESTS.%s)' "$M"; done
  printf '; do echo $$T; done\n'
}

build_module_variables() {
  printf 'MODULE_LINK.%s =' "$MODULE"
  if [ "$REQUIRE" ]; then
    printf " $TARGET_LIBRARY_DIR/lib%s.a" $REQUIRE
    printf ' $(MODULE_LINK.%s)' $REQUIRE
  fi

  printf '\nMODULE_LDFLAGS.%s = %s' "$MODULE" "$LINKER"
  if [ "$REQUIRE" ]; then
    printf ' -l%s' $REQUIRE
    printf ' $(MODULE_LDFLAGS.%s)' $REQUIRE
  fi

  printf '\nMODULE_TESTS.%s =' "$MODULE"
  [ "$TESTS" ] && printf ' %s' $TESTS

  printf '\nMODULE_HEADERS.%s =' "$MODULE"
  [ "$HEADERS" ] && printf " $TARGET_INCLUDE_DIR/%s" $HEADERS
  [ "$REQUIRE" ] && printf ' $(MODULE_HEADERS.%s)' $REQUIRE
  printf '\n.PHONY: %s-test\n' "$MODULE"
  printf '%s-test: $(MODULE_TESTS.%s)\n' "$MODULE" "$MODULE"
  printf 'test: %s-test\n' "$MODULE"
  printf '\n'
}

readonly BUILD_VARIABLE_RE='^MODULE_\(LINK\|LDFLAGS\|HEADERS\|TESTS\)\.[^= ]* ='
build_variable_filter() { sed -n "/${BUILD_VARIABLE_RE}/p"; }
build_rules_filter() { sed "/${BUILD_VARIABLE_RE}/d"; }

build_makefile() {
  build_prelude

  # Produce all normal rules (each ``module'' file evaluated in independent
  # sub-shell)
  MAKEFILE=$(for MODULE in $MODULES; do (
    readonly MODULE
    readonly MODULE_DIR="${BUILD_SOURCE_DIR:?}/$MODULE"
    readonly DEPEND="${TARGET_DEPEND_DIR:?}/mk-lib$MODULE.a"
    readonly TEST_DEPEND="${TARGET_DEPEND_DIR:?}/mk-test$MODULE.a"
    readonly LIBRARY="${TARGET_LIBRARY_DIR:?}/lib$MODULE.a"
    readonly GENERATED_SOURCE_DIR="$TARGET_SOURCE_DIR/$MODULE"
    readonly GENERATED_INCLUDE_DIR="$TARGET_INCLUDE_DIR/$MODULE"
    readonly MODULE_OBJECT_DIR="$TARGET_OBJECT_DIR/$MODULE"
    readonly MODULE_TEMP_DIR="$TARGET_TEMP_DIR/$MODULE"
    readonly TEST_TEMP_DIR="$TARGET_TEMP_DIR/$MODULE/test"
    readonly TEST_BIN_DIR="$TARGET_TEST_BINARY_DIR/$MODULE"

    cd "$MODULE_DIR"
    if [ -f module ]; then . ./module; fi

    build_module_variables

    if [ -z "$SOURCES$OBJECTS" ]; then append SOURCES *.c; fi
    for S in $SOURCES; do define_object "${S%.c}.o" "$S"; done

    build_module_targets
  ) ||Â exit 1; done)

  # Put variable definitions first and rules second
  echo "$MAKEFILE" | build_variable_filter
  echo
  echo "$MAKEFILE" | build_rules_filter

  build_postlude

  # Include recursive file dependencies
  if [ -d "$TARGET_DEPEND_DIR" ]; then
    find "$TARGET_DEPEND_DIR" -name '*.a' -exec $AR -p {} \;
  fi
}

build_main() {
  build_directories
  build_makefile | ${MAKE:-make -rf-} "$@"
}

build_main "$@"
