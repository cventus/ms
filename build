#!/bin/sh

set -e

: ${AR:=ar} \
  ${BUILD_CONFIG:=./build.conf}
readonly BUILD_CONFIG BUILD_ROOT=$(dirname "$BUILD_CONFIG")

# Make "append FOO item1 item2 ..." and "contains FOO item" available for list
# like variable FOO
decl_list() {
  eval "
    ${1}_append() { $1=\"\$$1\${$1:+ }\$*\"; }
    ${1}_contains() { expr \" \$$1 \" : \".* \$1 \" >/dev/null; }
  "
}

def_list() {
  def_list_name_=$1
  shift
  eval "$def_list_name_=\"$*\""
  decl_list "$def_list_name_"
}

append() {
  append_arg_=$1
  shift
  "${append_arg_}_append" "$@"
}

contains() {
  contains_arg_=$1
  shift
  "${contains_arg_}_contains" "$@"
}

globexists() {
  test -f "$1"
}

# Make list functions available in build configuration file
decl_list CFLAGS
decl_list CPPFLAGS
decl_list LDFLAGS

export CFLAGS LDFLAGS CPPFLAGS

# List of modules in this build
decl_list MODULES

# General directories
def_list TARGET_SHARED_DIRS lib depend bin
def_list TARGET_MODULE_DIRS obj test-bin src include
def_list TEMP_SHARED_DIRS
def_list TEMP_MODULE_DIRS

def_list RUN_ON_MODULE \
  build_module_link \
  build_module_tests \
  build_module_generated_headers \
  build_module_targets

# Initialize with build configuration
if [ -f "$BUILD_CONFIG" ]; then . "$BUILD_CONFIG"; fi

if [ -z "$MODULES" ]; then
  echo "Build modules not defined in environment or $BUILD_CONFIG" >&2
  exit 1
fi
readonly MODULES

# make path relative to build configuration file unless absolute
build_path() {
  if expr "$1" : "/" >/dev/null; then echo "$1"
  else echo "$BUILD_ROOT/$1"
  fi
}

# Variables that can be overridden in the build configuration
: ${TARGET:=target} \
  ${BUILD_SOURCE_DIR:=src} \
  ${BUILD_INCLUDE_DIR:=include}
: ${TARGET_TEMP_DIR:=$TARGET/tmp}

BUILD_SOURCE_DIR=$(build_path "$BUILD_SOURCE_DIR")
BUILD_INCLUDE_DIR=$(build_path "$BUILD_INCLUDE_DIR")

readonly TARGET TARGET_TEMP_DIR BUILD_SOURCE_DIR BUILD_INCLUDE_DIR

# Common cc flags
readonly INCLUDE_FLAGS="-I$TARGET/include -I$BUILD_INCLUDE_DIR"
readonly DEPEND_FLAGS='-MMD -MP -MT $@ -MF'

# Module specific variables, defined when module configuration is sourced
for L in SOURCES OBJECTS HEADERS REQUIRE LINKER TESTS; do
  def_list $L
done

BINARY=

require() { append REQUIRE "$@"; }
binary() { BINARY="${1:-$MODULE}"; }

# Short-hand functions for defining rules
target_generic() {
  target_generic_target_=$1
  shift
  printf '%s: %s\n' "$target_generic_target_" "$*"
}

target_phony() { target_generic .PHONY "$*"; }
target_source() { target_generic "$GENERATED_SOURCE_DIR/$@"; }
target_include() { target_generic "$TARGET/include/$@"; }
target_cc() { target_generic "$@" "\$(MODULE_HEADERS.$MODULE)"; }
target_ld() { target_generic "$@" "\$(MODULE_LINK.$MODULE)"; }
target_bin() { target_cc "$@" "\$(MODULE_LINK.$MODULE)"; }
end_target() { printf '\n'; }

# Functions for adding rule commands
sh_cmd() { printf '\t%s\n' "$*"; }
rm_cmd() { sh_cmd rm -f -- "$*"; }
ar_cmd() { sh_cmd '$(AR)' -rc "$*"; }

# Output command to compile a single source file (add neccessary compilation
# and preprocessor flags).
# Usage: cc_cmd <cc args>...
cc_cmd() { sh_cmd '$(CC) $(CFLAGS) $(CPPFLAGS)' "$INCLUDE_FLAGS" "$*"; }

# Output command to compile a single source file (add neccessary compilation
# and preprocessor flags) and generate makefile rules at the specified path at
# the same time.
# Usage: ccmk_cmd <makefile rules path> <cc args>...
ccmk_cmd() { cc_cmd "$DEPEND_FLAGS" "$@"; }

# Output command to compile and link a single source file (add neccessary
# linkage flags).
# Usage: ld_cmd <cc args>...
ld_cmd() {
  sh_cmd \
    '$(CC) $(CFLAGS) $(LDFLAGS)' \
    "-L$TARGET/lib" "$*" \
    "\$(MODULE_LDFLAGS.$MODULE)"
}

# Output command to compile and link a single source file (add neccessary
# linkage flags) and generate makefile rules at the specified path at the same
# time.
# Usage: ldmk_cmd <makefile rules path> <source file> [<cc args>...]
ldmk_cmd() { ld_cmd "$INCLUDE_FLAGS" "$DEPEND_FLAGS" "$@"; }

# Output command to compile a source file into an object with optional extra
# compiler flags (with default compilation flags) and generate makefile rules
# in the same directory as the object file (with a ".d" appended to the
# object's path name.
# Usage: object_cmd <target object> <source file> [<cc args>...]
object_cmd() {
  object_cmd_obj_="$1"
  shift 1
  ccmk_cmd "$object_cmd_obj_.d" -o "$object_cmd_obj_" -c "$@"
}

# Output a makefile rule to compile an object for a module.
# Usage: define_object <object> <source> [<cc flags> ...]
define_object() {
  define_object_obj_=$1
  define_object_src_="$MODULE_DIR/$2"
  shift 2

  append OBJECTS "$define_object_obj_"

  target_cc "$MODULE_OBJECT_DIR/$define_object_obj_" "$define_object_src_"
  object_cmd "$MODULE_OBJECT_DIR/$define_object_obj_" "$define_object_src_" "$@"
  end_target
}

build_module_link() {
  printf 'MODULE_LINK.%s =' "$MODULE"
  if [ "$REQUIRE" ]; then
    printf " $TARGET/lib/lib%s.a" $REQUIRE
    printf ' $(MODULE_LINK.%s)' $REQUIRE
  fi
  printf '\n'

  printf 'MODULE_LDFLAGS.%s = %s' "$MODULE" "$LINKER"
  if [ "$REQUIRE" ]; then
    printf ' -l%s' $REQUIRE
    printf ' $(MODULE_LDFLAGS.%s)' $REQUIRE
  fi
  printf '\n'
}

build_module_tests() {
  printf 'MODULE_TESTS.%s =' "$MODULE"
  [ "$TESTS" ] && printf ' %s' $TESTS
  printf '\n'

  target_phony "$MODULE"-test
  target_generic "$MODULE-test" "\$(MODULE_TESTS.$MODULE)"
  target_generic test "$MODULE"-test
}

build_module_generated_headers() {
  printf 'MODULE_HEADERS.%s =' "$MODULE"
  [ "$HEADERS" ] && printf " $TARGET/include/%s" $HEADERS
  [ "$REQUIRE" ] && printf ' $(MODULE_HEADERS.%s)' $REQUIRE
  printf '\n'
}

build_module_targets() {
  target_generic all "$MODULE"
  target_generic "$MODULE" "$LIBRARY"
  target_generic "lib$MODULE.a" "$LIBRARY"
  target_phony "$MODULE" "lib$MODULE.a"
  end_target

  # Default behavior when module configuration defines no sources nor objects.
  if [ -z "$SOURCES$OBJECTS" ] && globexists *.c; then append SOURCES *.c; fi
  for S in $SOURCES; do define_object "$(basename $S .c).o" $S; done

  build_module_targets_obj_=
  if [ "$OBJECTS" ]; then
    build_module_targets_obj_=$(printf " $MODULE_OBJECT_DIR/%s" $OBJECTS)
  fi

  target_generic "$LIBRARY" $build_module_targets_obj_
    ar_cmd -s '$@' '$?'
    ar_cmd "$DEPEND" '$(?:.o=.o.d)'
    rm_cmd '$(?:.o=.o.d)'
  end_target

  if [ "$BINARY" ]; then
    target_generic "$MODULE" "$TARGET/bin/$BINARY"

    if [ "$BINARY" != "$MODULE" ]; then
      target_generic "$BINARY" "$TARGET/bin/$BINARY"
      target_phony "$BINARY"
    fi

    target_ld "$TARGET/bin/$BINARY" "$LIBRARY"
      ld_cmd "$LIBRARY" -o "$TARGET/bin/$BINARY"
    end_target
  fi
}

build_mkdir() { if [ ! -d "$1" ]; then mkdir "$1"; fi; }

build_directories() {
  build_mkdir "$TARGET"
  build_mkdir "$TARGET_TEMP_DIR"

  for D in $TARGET_SHARED_DIRS $TARGET_MODULE_DIRS; do
    build_mkdir "$TARGET/$D"
  done
  for D in $TEMP_SHARED_DIRS $TEMP_MODULE_DIRS; do
    build_mkdir "$TARGET_TEMP_DIR/$D"
  done

  for MODULE in $MODULES; do
    for D in $TARGET_MODULE_DIRS; do
      build_mkdir "$TARGET/$D/$MODULE"
    done
    for D in $TEMP_MODULE_DIRS; do
      build_mkdir "$TARGET_TEMP_DIR/$D/$MODULE"
    done
  done
}

makefile_prolog() {
  target_generic all
  target_generic test
  target_generic clean
    sh_cmd find "$TARGET" -type f -exec rm -- {} '\;'
  end_target
  target_phony all test clean
  end_target
}

makefile_epilog() {
  target_generic list-tests
    sh_cmd \
      "for T in"$(printf ' $(MODULE_TESTS.%s)' $MODULES)"; do" \
        'echo $$T;' \
      'done'
  end_target
}

build_makefile() {
  makefile_prolog

  # Produce all normal rules (each ``module'' file evaluated in an independent
  # sub-shell)
  for MODULE in $MODULES; do (
    readonly MODULE
    readonly MODULE_DIR="$BUILD_SOURCE_DIR/$MODULE"
    readonly DEPEND="$TARGET/depend/mk-lib$MODULE.a"
    readonly LIBRARY="$TARGET/lib/lib$MODULE.a"
    readonly GENERATED_SOURCE_DIR="$TARGET/src/$MODULE"
    readonly GENERATED_INCLUDE_DIR="$TARGET/include/$MODULE"
    readonly MODULE_OBJECT_DIR="$TARGET/obj/$MODULE"
    readonly TEST_BIN_DIR="$TARGET/test-bin/$MODULE"

    cd "$MODULE_DIR"
    if [ -f module ]; then . ../$MODULE/module; fi
    for cmd in $RUN_ON_MODULE; do $cmd; done
  ) ||Â exit 1; done | awk '
  # Place variable definitions first and rules second
  {
    # Somewhat liberal variable parsing: expect no leading tab, equals sign
    # before the first colon; does not recognize variables with escaped
    # newlines before the equals sign.
    if (/^[^\t][^:=]*=/ || enl) {
      print;
      enl = /\\$/;
    } else rules[n++] = $0;
  }
  END {
    # Leave a blank line between variables and rules
    print "";
    for (i = 0; i < n; i++) print rules[i];
  }'

  # Include source header dependencies
  if [ -d "$TARGET/depend" ]; then
    find "$TARGET/depend" \
      -name '*.a' -exec $AR -p {} \; -o \
      -name '*.d' -exec cat {} \;
  fi

  makefile_epilog
}

main() {
  build_directories
  build_makefile | ${MAKE:-make -rf-} "$@"
}

main "$@"
