#!/bin/sh

set -e

if [ -f "${BUILD_CONFIG:=./build.conf}" ]; then . "$BUILD_CONFIG"; fi

MODULES="${MODULES:?Build modules not defined in environment or $BUILD_CONFIG}"
readonly MODULES

case "${BUILD_SOURCE_DIR:=src}" in
(/*) ;; (*) BUILD_SOURCE_DIR="$(dirname "$BUILD_CONFIG")/$BUILD_SOURCE_DIR";;
esac

case "${BUILD_INCLUDE_DIR:=include}" in
(/*) ;; (*) BUILD_INCLUDE_DIR="$(dirname "$BUILD_CONFIG")/$BUILD_INCLUDE_DIR";;
esac

TARGET_NAME="${TARGET_NAME:-target}"
readonly TARGET_TEMP_DIR="${TARGET_TEMP_DIR:-$TARGET_NAME/tmp}"
readonly BUILD_SOURCE_DIR BUILD_INCLUDE_DIR TARGET_NAME

# General directories
readonly TARGET_LIBRARY_DIR="$TARGET_NAME/lib"
readonly TARGET_DEPEND_DIR="$TARGET_NAME/dep"
readonly TARGET_BINARY_DIR="$TARGET_NAME/bin"

# Module specific test binaries
readonly TARGET_TEST_BINARY_DIR="$TARGET_NAME/test"

# Generated sources
readonly TARGET_SOURCE_DIR="$TARGET_NAME/src"
readonly TARGET_INCLUDE_DIR="$TARGET_NAME/include"

# module definition API
BINARY() { BINNAME="${1:-$MODULE}"; }
SOURCE() { SOURCES="$SOURCES $@"; }
HEADER() { HEADERS="$HEADERS $@"; }
LINKER() { LIBRARIES="$LIBRARIES $@"; }
TEST() { TESTS="$TESTS $@"; }
REQUIRE() { REQUIREMENTS="$REQUIREMENTS $@"; }
OBJECT()
{
  MEMBER="${1%.o}"
  MEMBER_SOURCE="${BUILD_SOURCE_DIR:?}/$MODULE/$2"
  shift 2
  OBJECTS="$OBJECTS $MEMBER.o"
  build_member_rule "$TARGET_TEMP_DIR/$MODULE" "$MEMBER" "$MEMBER_SOURCE" "$@"
}

# Makefile rule generation

build_source_target()
{
  generated_target=$1
  shift
  echo "$TARGET_SOURCE_DIR/$MODULE/$generated_target: $*"
}

build_recipe_line()
{
  printf '\t%s\n' "$*"
}

build_include_target()
{
  generated_target=$1
  shift
  echo "$TARGET_INCLUDE_DIR/$generated_target: $*"
}

build_source_recipe()
{
  printf '\t$(CC) $(CFLAGS) $(CPPFLAGS) -I"%s" -I"%s" %s\n' \
    "$TARGET_INCLUDE_DIR" "$BUILD_INCLUDE_DIR" "$*"
}

build_binary_recipe()
{
  printf '\t$(CC) $(CFLAGS) $(LDFLAGS) -L%s %s\n' \
    "$TARGET_LIBRARY_DIR" "$*"
}

build_depend_flags()
{
  echo -MMD -MP -MT "\"$1\"" -MF "\"$2\""
}

# <output path> <name> <source> [<extra cc args>...]
# Print rules (but not a target) to create "<output path>/<name>.o" and
# "<output path>/<name>.d" to standard output
build_member_rule()
{
  OBJECT_PATH="$1/$2.o"
  MEMBER_PATH="$LIBRARY($2.o)"
  MKFILE_PATH="$1/$2.d"
  SOURCE_PATH=$3
  shift 3

  # Module library rule
  echo "$MEMBER_PATH: $SOURCE_PATH \$(MODULE_HEADERS.$MODULE)"
  build_source_recipe "$@" \
    $(build_depend_flags "$MEMBER_PATH" "$MKFILE_PATH") \
    -o "\"$OBJECT_PATH\"" -c "\"$SOURCE_PATH\""
  printf '\t$(AR) -rc "%s" "%s"\n' "$LIBRARY" "$OBJECT_PATH"
  printf '\t$(AR) -rc "%s" "%s"\n' "$DEPEND" "$MKFILE_PATH"
  printf '\trm \"%s\" \"%s\"\n\n' "$OBJECT_PATH" "$MKFILE_PATH"
}

# target/lib/libfoo.a: target/lib/libfoo.a(bar.o baz.o)
#         $(AR) -s target/lib/libfoo.a
build_lib_target() {
  printf '%s: %s( ' "$LIBRARY" "$LIBRARY"
  printf '\\\n\t%s ' $OBJECTS
  printf ')\n\t$(AR) -s "%s"\n\n' "$LIBRARY"
}

build_bin_target() {
  printf '%s: %s\n\n' "$MODULE" "$TARGET_BINARY_DIR/$BINNAME"

  if [ "$BINNAME" != "$MODULE" ]; then
    printf '%s: %s\n' "$BINNAME" "$TARGET_BINARY_DIR/$BINNAME"
    printf '.PHONY: %s\n' "$BINNAME"
  fi

  printf '%s/%s: %s $(MODULE_LINK.%s)\n' \
    "$TARGET_BINARY_DIR" "$BINNAME" "$LIBRARY" "$MODULE"

  build_binary_recipe "$LIBRARY" "\$(MODULE_LDFLAGS.$MODULE)" -o "\"$TARGET_BINARY_DIR/$BINNAME\""

  echo
}

build_module_target() {
  printf '%s: %s\n\n' "$MODULE" "$LIBRARY"
  printf '%s: %s\n\n' "lib$MODULE.a" "$LIBRARY"
  printf '.PHONY: %s %s\n\n' "$MODULE" "lib$MODULE.a"
  printf 'all: %s\n\n' "$MODULE"

  build_lib_target
  if [ -n "$BINNAME" ]; then build_bin_target; fi
}

build_mkdir() { if [ ! -d "$1" ]; then mkdir "$1"; fi; }

build_directories() {
  build_mkdir "$TARGET_NAME"
  build_mkdir "$TARGET_TEMP_DIR"
  build_mkdir "$TARGET_LIBRARY_DIR"
  build_mkdir "$TARGET_DEPEND_DIR"
  build_mkdir "$TARGET_BINARY_DIR"

  build_mkdir "$TARGET_TEST_BINARY_DIR"
  build_mkdir "$TARGET_SOURCE_DIR"
  build_mkdir "$TARGET_INCLUDE_DIR"

  for MODULE in $MODULES; do
    # For object and dependency files
    build_mkdir "$TARGET_TEMP_DIR/$MODULE"

    # For test object and dependency files
    build_mkdir "$TARGET_TEMP_DIR/$MODULE/test"

    # Test binaries
    build_mkdir "$TARGET_TEST_BINARY_DIR/$MODULE"

    # Generated files
    build_mkdir "$TARGET_SOURCE_DIR/$MODULE"
    build_mkdir "$TARGET_INCLUDE_DIR/$MODULE"
  done
}

build_prelude() {
  # Prelude rules
  printf '.POSIX:\n.SUFFIXES:\n'
  printf 'all:\nclean: clean-dep clean-lib clean-bin\n'
  printf 'clean-dep: ; rm -f %s/*\n' "${TARGET_DEPEND_DIR:?}"
  printf 'clean-lib: ; rm -f %s/*\n' "${TARGET_LIBRARY_DIR:?}"
  printf 'clean-bin: ; rm -f %s/*\n\n' "${TARGET_BINARY_DIR:?}"
  printf '.PHONY: all clean clean-dep clean-lib clean-bin\n\n'
}

build_postlude() {
  printf 'list-tests:\n\tfor T in'
  for M in $MODULES; do printf ' $(MODULE_TESTS.%s)' "$M"; done
  printf '; do echo $$T; done\n'
}

build_module_variables() {
  printf 'MODULE_LINK.%s =' "$MODULE"
  for R in $REQUIREMENTS; do
    printf ' %s/lib%s.a $(MODULE_LINK.%s)' "$TARGET_LIBRARY_DIR" "$R" "$R"
  done

  printf '\nMODULE_LDFLAGS.%s = %s' "$MODULE" "$LIBRARIES"
  if [ "$REQUIREMENTS" ]; then
    printf ' -l%s' $REQUIREMENTS
    printf ' $(MODULE_LDFLAGS.%s)' $REQUIREMENTS
  fi
  printf '\n'

  printf '\nMODULE_TESTS.%s =' "$MODULE"
  printf ' %s' $TESTS
  printf '\n'

  printf '\nMODULE_HEADERS.%s =' "$MODULE"
  if [ "$HEADERS" ]; then printf " $TARGET_INCLUDE_DIR/%s" $HEADERS; fi
  if [ "$REQUIREMENTS" ]; then printf ' $(MODULE_HEADERS.%s)' $REQUIREMENTS; fi
  printf '\n'

  printf 'test-%s:\n' "$MODULE"
  printf '.PHONY: test-%s\n' "$MODULE"
  printf 'test: test-%s\n' "$MODULE"
  printf '\n'
}

readonly BUILD_VARIABLE_RE='^MODULE_\(LINK\|LDFLAGS\|HEADERS\|TESTS\)\.[^= ]* ='
build_variable_filter() { sed -n "/${BUILD_VARIABLE_RE}/p"; }
build_rules_filter() { sed "/${BUILD_VARIABLE_RE}/d"; }

build_makefile() {
  unset BINNAME REQUIREMENTS SOURCES OBJECTS LIBRARIES TESTS HEADERS

  build_prelude

  # Produce all normal rules (each ``module'' file evaluated in independent
  # sub-shell)
  MAKEFILE=$(for MODULE in $MODULES; do (
    DEPEND="${TARGET_DEPEND_DIR:?}/m$MODULE.a"
    TEST_DEPEND="${TARGET_DEPEND_DIR:?}/t$MODULE.a"
    LIBRARY="${TARGET_LIBRARY_DIR:?}/lib$MODULE.a"
    MODULE_DIR="$BUILD_SOURCE_DIR/$MODULE"
    GENERATED_SOURCE_DIR="$TARGET_SOURCE_DIR/$MODULE"
    GENERATED_INCLUDE_DIR="$TARGET_INCLUDE_DIR/$MODULE"
    readonly MODULE DEPEND TEST_DEPEND LIBRARY MODULE_DIR
    readonly GENERATED_SOURCE_DIR GENERATED_SOURCE_DIR

    cd "$MODULE_DIR"
    if [ -f module ]; then . ./module; fi

    build_module_variables

    if [ -z "$SOURCES" -a -z "$OBJECTS" ]; then SOURCES=*.c; fi
    for MEMBER_SOURCE in $SOURCES; do
      OBJECT "$(basename $MEMBER_SOURCE .c).o" "$MEMBER_SOURCE"
    done

    build_module_target
  ) ||Â exit 1; done)

  # Put variable definitions first and rules second
  echo "$MAKEFILE" | build_variable_filter
  echo "$MAKEFILE" | build_rules_filter

  build_postlude

  # Include recursive file dependencies
  if [ -d "$TARGET_DEPEND_DIR" ]; then
    find "$TARGET_DEPEND_DIR" -name '*.a' -exec "${AR:-ar}" -p {} \;
  fi
}

build_main() {
  build_directories
  build_makefile | ${MAKE:-make -rf-} "$@"
}

build_main "$@"
