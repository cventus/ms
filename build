#!/bin/sh

set -e

AR=${AR:-ar}

# Make "append FOO item1 item2 ..." available for list like variable FOO
decl_list()
{
  eval "${1}_append() {
    $1=\"\$$1\${$1:+ }\$*\";
  }"
}

def_list()
{
  eval "$1=''"
  decl_list "$1"
}

append()
{
  append_arg_=$1
  shift
  "${append_arg_}_append" "$@"
}

decl_list MODULES

# Initialize with build configuration
if [ -f "${BUILD_CONFIG:=./build.conf}" ]; then . "$BUILD_CONFIG"; fi

if [ -z "$MODULES" ]; then
  echo "Build modules not defined in environment or $BUILD_CONFIG" >&2
  exit 1
fi
readonly MODULES

case "${BUILD_SOURCE_DIR:=src}" in
(/*) ;; (*) BUILD_SOURCE_DIR="$(dirname "$BUILD_CONFIG")/$BUILD_SOURCE_DIR";;
esac
readonly BUILD_SOURCE_DIR

case "${BUILD_INCLUDE_DIR:=include}" in
(/*) ;; (*) BUILD_INCLUDE_DIR="$(dirname "$BUILD_CONFIG")/$BUILD_INCLUDE_DIR";;
esac
readonly BUILD_INCLUDE_DIR

readonly TARGET_NAME="${TARGET_NAME:-target}"
readonly TARGET_TEMP_DIR="${TARGET_TEMP_DIR:-$TARGET_NAME/tmp}"

# General directories
readonly TARGET_LIBRARY_DIR="$TARGET_NAME/lib"
readonly TARGET_DEPEND_DIR="$TARGET_NAME/dep"
readonly TARGET_BINARY_DIR="$TARGET_NAME/bin"
readonly TARGET_OBJECT_DIR="$TARGET_NAME/obj"

# Module specific test binaries
readonly TARGET_TEST_BINARY_DIR="$TARGET_NAME/test"

# Generated sources
readonly TARGET_SOURCE_DIR="$TARGET_NAME/src"
readonly TARGET_INCLUDE_DIR="$TARGET_NAME/include"

# Module specific lists, defined when module configuration is sourced
def_list SOURCES
def_list OBJECTS
def_list HEADERS
def_list REQUIRE
def_list LINKER
def_list TESTS

BINARY=

require() { append REQUIRE "$@"; }
binary() { BINARY="${1:-$MODULE}"; }

# Short-hand functions for defining rules
phony_target()
{
  printf '.PHONY: %s\n' "$*"
}

target_generic()
{
  TARGET_=$1
  shift
  printf '%s: %s\n' "$TARGET_" "$*"
}

target_source()
{
  TARGET_=$1
  shift
  printf '%s: %s\n' "$GENERATED_SOURCE_DIR/$TARGET_" "$*"
}

target_include()
{
  TARGET_=$1
  shift
  printf '%s: %s\n' "$TARGET_INCLUDE_DIR/$TARGET_" "$*"
}

target_cc()
{
  TARGET_=$1
  shift
  printf '%s: %s $(MODULE_HEADERS.%s)\n' "$TARGET_" "$*" "$MODULE"
}

target_ld()
{
  TARGET_=$1
  shift
  printf '%s: %s $(MODULE_LINK.%s)\n' "$TARGET_" "$*" "$MODULE"
}

target_bin()
{
  TARGET_=$1
  shift
  printf '%s: %s $(MODULE_LINK.%s) $(MODULE_HEADERS.%s)\n' \
    "$TARGET_" "$*" "$MODULE" "$MODULE"
}

end_target()
{
  echo
}

# Functions for adding rule commands
sh_cmd()
{
  printf '\t%s\n' "$*"
}

rm_cmd()
{
  printf '\trm -f -- %s\n' "$*"
}

cc_cmd()
{
  printf '\t$(CC) $(CFLAGS) $(CPPFLAGS) -I"%s" -I"%s" %s\n' \
    "$TARGET_INCLUDE_DIR" "$BUILD_INCLUDE_DIR" "$*"
}

ld_cmd()
{
  printf "\t\
\$(CC) \$(CFLAGS) \$(LDFLAGS) \
-L$TARGET_LIBRARY_DIR %s \
\$(MODULE_LDFLAGS.$MODULE)\n" \
    "$*"
}

# <object> <source> [<extra cc args>...]
# Output command to compile <source> into <object> with optional extra flags.
# Create path/to/foo.d from path/to/foo.o as a secondary output.
object_cmd()
{
  OBJECT_="$1"
  MKFILE_="${OBJECT_%.o}.d"
  SOURCE_="$2"
  shift 2

  cc_cmd "$@" \
    -MMD -MP -MT '$@' -MF "\"$MKFILE_"\" \
    -c "\"$SOURCE_"\" \
    -o "\"$OBJECT_"\"
}

# <archive> [<member> ...]
ar_cmd()
{
  printf '\t$(AR) -rc %s\n' "$*"
}

#
define_object()
{
  MEMBER="${1%.o}"
  MEMBER_SOURCE="$MODULE_DIR/$2"
  shift 2

  append OBJECTS $MEMBER.o

  target_cc "$MODULE_OBJECT_DIR/$MEMBER.o" "$MEMBER_SOURCE"
  object_cmd "$MODULE_OBJECT_DIR/$MEMBER.o" "$MEMBER_SOURCE" "$@"
}

define_module_targets() {
  target_generic all "$MODULE"
  target_generic "$MODULE" "$LIBRARY"
  target_generic "lib$MODULE.a" "$LIBRARY"
  phony_target "$MODULE" "lib$MODULE.a"
  end_target

  target_generic "$LIBRARY" $(printf " ${MODULE_OBJECT_DIR}/%s" $OBJECTS)
  ar_cmd -s '$@' '$?'
  ar_cmd "$DEPEND" '$(?:.o=.d)'
  rm_cmd '$(?:.o=.d)'
  end_target

  if [ "$BINARY" ]; then
    target_generic "$MODULE" "$TARGET_BINARY_DIR/$BINARY"

    if [ "$BINARY" != "$MODULE" ]; then
      target_generic "$BINARY" "$TARGET_BINARY_DIR/$BINARY"
      phony_target "$BINARY"
    fi

    target_ld "$TARGET_BINARY_DIR/$BINARY" "$LIBRARY"
    ld_cmd "$LIBRARY" -o "\"$TARGET_BINARY_DIR/$BINARY\""
    end_target
  fi
}

build_mkdir() { if [ ! -d "$1" ]; then mkdir "$1"; fi; }

build_directories() {
  build_mkdir "$TARGET_NAME"
  build_mkdir "$TARGET_TEMP_DIR"
  build_mkdir "$TARGET_LIBRARY_DIR"
  build_mkdir "$TARGET_DEPEND_DIR"
  build_mkdir "$TARGET_BINARY_DIR"
  build_mkdir "$TARGET_OBJECT_DIR"

  build_mkdir "$TARGET_TEST_BINARY_DIR"
  build_mkdir "$TARGET_SOURCE_DIR"
  build_mkdir "$TARGET_INCLUDE_DIR"

  for MODULE in $MODULES; do
    # For object and dependency files
    build_mkdir "$TARGET_TEMP_DIR/$MODULE"
    build_mkdir "$TARGET_OBJECT_DIR/$MODULE"

    # For test object and dependency files
    build_mkdir "$TARGET_TEMP_DIR/$MODULE/test"

    # Test binaries
    build_mkdir "$TARGET_TEST_BINARY_DIR/$MODULE"

    # Generated files
    build_mkdir "$TARGET_SOURCE_DIR/$MODULE"
    build_mkdir "$TARGET_INCLUDE_DIR/$MODULE"
  done
}

makefile_prelude() {
  target_generic all
  target_generic clean
  sh_cmd find "\"$TARGET_NAME"\" -type f -exec rm -- {} '\;'
  end_target
  phony_target all clean
}

makefile_postlude() {
  target_generic list-tests
  sh_cmd \
  'for T in ' $(printf ' $(MODULE_TESTS.%s)' $MODULES) '; do ' \
    'echo $$T; '\
  'done'
  end_target
}

build_module_variables() {
  printf 'MODULE_LINK.%s =' "$MODULE"
  if [ "$REQUIRE" ]; then
    printf " $TARGET_LIBRARY_DIR/lib%s.a" $REQUIRE
    printf ' $(MODULE_LINK.%s)' $REQUIRE
  fi

  printf '\nMODULE_LDFLAGS.%s = %s' "$MODULE" "$LINKER"
  if [ "$REQUIRE" ]; then
    printf ' -l%s' $REQUIRE
    printf ' $(MODULE_LDFLAGS.%s)' $REQUIRE
  fi

  printf '\nMODULE_TESTS.%s =' "$MODULE"
  [ "$TESTS" ] && printf ' %s' $TESTS

  printf '\nMODULE_HEADERS.%s =' "$MODULE"
  [ "$HEADERS" ] && printf " $TARGET_INCLUDE_DIR/%s" $HEADERS
  [ "$REQUIRE" ] && printf ' $(MODULE_HEADERS.%s)' $REQUIRE

  printf '\n.PHONY: %s-test\n' "$MODULE"
  printf '%s-test: $(MODULE_TESTS.%s)\n' "$MODULE" "$MODULE"
  printf 'test: %s-test\n' "$MODULE"
  printf '\n'
}

readonly BUILD_VARIABLE_RE='^MODULE_\(LINK\|LDFLAGS\|HEADERS\|TESTS\)\.[^= ]* ='
build_variable_filter() { sed -n "/${BUILD_VARIABLE_RE}/p"; }
build_rules_filter() { sed "/${BUILD_VARIABLE_RE}/d"; }

build_makefile() {
  makefile_prelude

  # Produce all normal rules (each ``module'' file evaluated in independent
  # sub-shell)
  MAKEFILE=$(for MODULE in $MODULES; do (
    readonly MODULE
    readonly MODULE_DIR="${BUILD_SOURCE_DIR:?}/$MODULE"
    readonly DEPEND="${TARGET_DEPEND_DIR:?}/mk-lib$MODULE.a"
    readonly LIBRARY="${TARGET_LIBRARY_DIR:?}/lib$MODULE.a"
    readonly GENERATED_SOURCE_DIR="$TARGET_SOURCE_DIR/$MODULE"
    readonly GENERATED_INCLUDE_DIR="$TARGET_INCLUDE_DIR/$MODULE"
    readonly MODULE_OBJECT_DIR="$TARGET_OBJECT_DIR/$MODULE"
    readonly MODULE_TEMP_DIR="$TARGET_TEMP_DIR/$MODULE"
    readonly TEST_TEMP_DIR="$TARGET_TEMP_DIR/$MODULE/test"
    readonly TEST_BIN_DIR="$TARGET_TEST_BINARY_DIR/$MODULE"

    cd "$MODULE_DIR"
    if [ -f module ]; then . ./module; fi

    build_module_variables

    if [ -z "$SOURCES$OBJECTS" ]; then append SOURCES *.c; fi
    for S in $SOURCES; do define_object "${S%.c}.o" "$S"; done

    define_module_targets
  ) ||Â exit 1; done)

  # Put variable definitions first and rules second
  echo "$MAKEFILE" | build_variable_filter
  echo
  echo "$MAKEFILE" | build_rules_filter

  # Include recursive file dependencies
  if [ -d "$TARGET_DEPEND_DIR" ]; then
    find "$TARGET_DEPEND_DIR" -name '*.a' -exec $AR -p {} \;
  fi

  makefile_postlude
}

main() {
  build_directories
  build_makefile | ${MAKE:-make -rf-} "$@"
}

main "$@"
